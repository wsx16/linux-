# 第一天

## 启动流程各阶段的核心作用

1.  **iROM 代码运行（romboot）**
    -   是固化在 SOC 芯片内部的`bootrom`代码，是设备上电后执行的第一段代码。
    -   操作：完成基础硬件初始化，识别启动介质（SD/USB/EMMC）；读取部分代码到 iRAM（称为 SPL，即第二阶段程序加载器），实现 “小内存启动过渡”。
2.  **iRAM（SPL）代码运行**
    -   属于 bootloader 的第一阶段，因 iRAM 空间较小，仅执行关键初始化。
    -   操作：初始化系统时钟、外部内存（如 DDR）；将 bootloader 主程序（如`u-boot.bin`）搬运到 DDR（DDR 内存更大，支持复杂操作）。
3.  **DDR 中运行 bootloader 第二阶段代码**
    -   是 bootloader 的主执行阶段，可完成更丰富的硬件配置。
    -   操作：初始化串口、EMMC、SD 等设备；将操作系统（如 Linux）加载到内存中。
4.  **系统最终启动**
    -   运行内存中的操作系统→挂载文件系统→启动应用程序，完成设备启动。

## 补充说明

bootloader 在嵌入式设备中的角色类似计算机的 BIOS：负责硬件初始化、引导操作系统加载，是连接硬件与系统的 “启动桥梁”。这种分阶段启动的设计，是为了适配嵌入式设备初期（上电时）内存资源有限的特点，逐步扩展硬件能力后再加载复杂程序。

### 芯片的 iROM（内部只读存储器）代码不完成系统时钟和内存初始化的主要原因

#### 1. 硬件多样性限制

-   **内存配置多样化**：不同板卡使用的 DDR 内存类型（DDR2/DDR3/LPDDR）、容量、时序参数各不相同，无法在芯片出厂时固化一套通用配置
-   **时钟系统复杂性**：外部晶振频率、PLL 倍频设置、各模块时钟分频比等因板而异

#### 2. iROM 的设计定位

-   **最小化引导代码**：iROM 只负责最基本的 CPU 核心初始化
-   **单一职责原则**：iROM 的主要任务是识别启动介质（SD卡、eMMC、USB等）并加载下一阶段引导程序（BL1/BL2）
-   **代码空间有限**：iROM 容量通常很小（几十KB），无法容纳复杂的硬件初始化代码

#### 3. 灵活性与可移植性

-   **支持多种硬件平台**：同一芯片（如 Exynos4412）可用于不同的开发板（如 FS4412、Origen 等）
-   **便于硬件迭代**：新版本板卡更换内存芯片时，只需更新引导程序，无需修改芯片固件
-   **降低芯片成本**：减少 iROM 容量需求，降低芯片制造成本

#### 4. 安全启动考虑

-   **信任链传递**：iROM 作为信任根，验证下一阶段引导程序的签名，将具体硬件初始化交给已验证的 BL1
-   **错误隔离**：避免因硬件初始化失败导致 iROM 代码无法恢复

#### 5. 启动流程分层

典型的启动顺序为：

```
iROM → BL1（初始化时钟、内存） → BL2 → U-Boot → Linux内核
```

-   **iROM**：芯片固化，不可更改
-   **BL1/BL2**：板级相关，由板卡厂商提供
-   这种分层设计实现了芯片通用性与板卡特定需求的平衡

### Q&A

#### 1. 板子最先启动的程序是什么，做了什么事？

最先启动的程序是**Bootloader（如 U-Boot）**，部分芯片会先执行内部 ROM（如 Exynos4412 的 iROM）的初始化，但核心启动程序是 Bootloader，作用包括：

-   硬件初始化：初始化 CPU、时钟、内存、串口、存储等核心硬件；
-   加载内核：从 eMMC / 网络读取 Linux 内核到内存；
-   引导系统：将 CPU 控制权交给内存中的内核，启动 Linux。

#### 2. 为什么要初始化时钟，为什么要初始化内存？

-   **初始化时钟**：硬件模块（CPU、外设）依赖时钟信号运行，不同模块需不同频率（如 CPU 需 1GHz、串口需对应波特率时钟）；初始化时钟是为硬件分配合适的时钟源，保证硬件稳定工作。
-   **初始化内存**：内核、程序需加载到内存（DRAM）运行；初始化内存是配置内存控制器、识别内存空间，为后续加载内核提供存储载体。

#### 3. 板子的启动信息，哪些是内核的，哪些是 bootloader 的，哪些是文件系统的？

-   **Bootloader 的信息**：U-Boot 版本、CPU / 内存 / 存储初始化、加载内核的过程（如 “TFTP from server...”）。
-   **内核的信息**：驱动初始化（网卡 / MMC 驱动）、IP 配置、根文件系统挂载准备（如 “IP-Config: Complete”）。
-   **文件系统的信息**：根文件系统挂载日志（如 “VFS: Mounted root”）、文件系统类型（NFS/ext4）。

#### 4. 为什么要挂文件系统？

文件系统是管理存储设备文件的规则，“挂载” 是将存储设备关联到系统目录树；挂载后系统才能识别存储中的文件结构，读取应用程序、配置文件等，无挂载时存储仅为 “裸设备”，无法访问文件。

#### 5. 不同压缩包的后缀有什么区别？

常见压缩包后缀的核心区别（按工具 / 算法分类）：

| 后缀 | 压缩工具 | 核心算法 | 特点 |
| :--- | :--- | :--- | :--- |
| `.tar` | `tar` | 仅打包（无压缩） | 合并文件，不减小体积 |
| `.tar.gz` | `tar+gzip` | DEFLATE | 压缩率较高，解压速度快 |
| `.tar.bz2` | `tar+bzip2` | Burrows-Wheeler | 压缩率比.gz 高，解压较慢 |
| `.zip` | `zip` | DEFLATE | 跨平台（Windows/Linux） |
| `.rar` | `rar` | RAR 专有算法 | 压缩率高，但 Linux 默认不支持 |

#### 6. 常见的平台架构有哪些，不同的平台架构需要不同的交叉开发工具链？

-   **常见平台架构**：
    1.  **x86/x86_64**：PC、服务器的主流架构；
    2.  **ARM**：嵌入式设备（FS4412 开发板）、手机的主流架构；
    3.  **MIPS**：路由器、机顶盒常用架构；
    4.  **PowerPC**：工业设备、嵌入式系统常用架构。
-   **交叉工具链的对应关系**：不同架构的 CPU 指令集不同（如 ARM 和 x86 的机器指令不兼容），因此需为每个架构定制交叉工具链（如 ARM 对应`arm-linux-gcc`，x86 对应`gcc`）。

#### 7. PATH 环境变量的用途

PATH 是系统的 “可执行程序搜索路径列表”，当输入命令（如`arm-linux-gcc`）时，系统会依次在 PATH 包含的目录中查找对应的可执行程序；用途包括：

-   让系统快速找到命令，无需输入完整路径；
-   配置交叉工具链时，需将工具链的`bin`目录加入 PATH，才能直接使用`arm-linux-gcc`等命令。

#### 8. bootargs 的用途及内容的含义

`bootargs`是**U-Boot 传递给 Linux 内核的启动参数**，用于告诉内核系统的硬件配置、根文件系统位置等信息，常见内容及含义（以你的配置为例）：

-   `root=/dev/nfs`：指定根文件系统类型为 NFS；
-   `nfsroot=192.168.2.50:/xxx/rootfs`：指定 NFS 根文件系统的服务器 IP 和共享目录；
-   `rw`：根文件系统以读写模式挂载；
-   `console=ttySAC2,115200`：指定串口 2 为系统控制台，波特率 115200；
-   `init=/linuxrc`：指定内核启动后执行的第一个程序（`linuxrc`是嵌入式系统的初始化程序）；
-   `ip=192.168.2.198`：指定开发板的 IP 地址。

# 第二天


## Linux 内核目录核心结构

| 目录 / 文件 | 作用说明 |
| :--- | :--- |
| arch 目录 | 存放硬件架构（如 arm）相关代码：<br>- `arch/arm/boot/compressed`：内核自解压代码（压缩内核启动时自动解压）；<br>- `arch/arm/kernel/head.S`：Linux 内核的启动入口代码；<br>- `arch/arm/boot/dts`：设备树源文件（存储开发板硬件信息，替代传统硬编码）；<br>- `arch/arm/configs`：SOC 对应的内核配置文件（预定义硬件的编译选项） |
| driver 目录 | 存放所有硬件设备的驱动代码（外设、存储、网络设备等） |
| net 目录 | 实现 TCP/IP、UDP 等网络协议的代码 |
| Makefile 文件 | 内核编译的核心配置文件，指定目标架构（ARCH）、交叉编译工具链（CROSS_COMPILE）等编译参数 |

## Kernel Menuconfig 选项

-   `bool --> []`
    -   `[*]` --> 对应的驱动被编译到uImage中
    -   `[ ]` --> 对应的驱动不被编译
-   `tristate --> <>` (三态)
    -   `<*>` --> 对应的驱动被编译到uImage中
    -   `< >` --> 对应的驱动不被编译
    -   `<M>` --> 对应的驱动采用模块化的方式进行编译，使用`make modules`命令编译模块化的驱动程序

## busybox

![76597277643](C:\Users\魏士雄\AppData\Local\Temp\1765972776435.png)

# 第三天

![76604572595](C:\Users\魏士雄\AppData\Local\Temp\1766045725958.png)
![76604600758](C:\Users\魏士雄\AppData\Local\Temp\1766046007581.png)
![76604680875](C:\Users\魏士雄\AppData\Local\Temp\1766046808756.png)
![76604690409](C:\Users\魏士雄\AppData\Local\Temp\1766046904090.png)
![76604700066](C:\Users\魏士雄\AppData\Local\Temp\1766047000661.png)
![76604707939](C:\Users\魏士雄\AppData\Local\Temp\1766047079390.png)
![76604726832](C:\Users\魏士雄\AppData\Local\Temp\1766047268327.png)
![76604668244](C:\Users\魏士雄\AppData\Local\Temp\1766046682440.png)
![76604737367](C:\Users\魏士雄\AppData\Local\Temp\1766047373677.png)
![76604749557](C:\Users\魏士雄\AppData\Local\Temp\1766047495573.png)
![76604799190](C:\Users\魏士雄\AppData\Local\Temp\1766047991909.png)
![76604814630](C:\Users\魏士雄\AppData\Local\Temp\1766048146305.png)
![76604833902](C:\Users\魏士雄\AppData\Local\Temp\1766048339028.png)
![76594288768](C:\Users\魏士雄\AppData\Local\Temp\1765942887680.png)

## /etc/inittab 文件

该文件是 `init` 进程的行为规则表，用于指定系统启动、异常重启、按键触发等场景下需执行的程序 / 脚本，是嵌入式系统启动流程的核心配置之一。

### 各配置项解析

| 配置条目 | 动作（action） | 功能说明 |
| :--- | :--- | :--- |
| `::sysinit:/etc/init.d/rcS` | `sysinit` | 系统初始化阶段执行`/etc/init.d/rcS`脚本（除单用户模式外，这是系统启动后最先运行的逻辑）。`rcS`是嵌入式系统的核心启动脚本，负责挂载文件系统、初始化硬件设备、启动基础服务等。 |
| `::respawn:-/bin/sh` | `respawn` | 若进程退出，则自动重启该进程。此处是在控制台启动`/bin/sh`（`-`表示为 “登录 shell”），保证控制台始终有交互 shell 可用（若用户退出 shell，init 会重新启动它）。 |
| `::restart:/sbin/init` | `restart` | 当 init 进程自身重启时，执行`/sbin/init`以重新初始化 init 流程。 |
| `::ctrlaltdel:/sbin/reboot`| `ctrlaltdel` | 当用户按下`Ctrl+Alt+Del`组合键时，执行`/sbin/reboot`命令重启系统。 |

### 适配嵌入式场景的特点

该配置基于 busybox 的 init 工具，省略了传统 Linux inittab 中的 “运行级别（runlevels）” 字段 —— 因为嵌入式系统通常无需多运行级别（如桌面系统的 “图形模式”“命令行模式”），配置更简化、资源占用更低。

*注意：以下图片链接为本地路径，可能无法正常显示。*
![76595111716](C:\Users\魏士雄\AppData\Local\Temp\1765951117168.png)

### inittab `action` 详解

`action`是 BusyBox inittab 的核心配置项，定义了`process`（待执行程序 / 脚本）的执行规则，具体如下：

| action | 含义与执行特点 | 适用场景 |
| :--- | :--- | :--- |
| sysinit | 系统启动后**最先执行**，仅执行 1 次；init 进程会等待其执行结束，再继续后续操作。 | 启动核心初始化脚本（如`/etc/init.d/rcS`） |
| wait | 在`sysinit`执行完成后执行，仅执行 1 次；init 进程会等待其执行结束。 | 依赖初始化环境的启动任务 |
| once | 在`wait`执行完成后执行，仅执行 1 次；init 进程**不等待**其执行结束。 | 无需阻塞后续流程的一次性任务 |
| respawn | 在`once`执行完成后启动；若`process`退出，init 进程会**自动重启**该进程。 | 保持控制台 shell、核心后台服务 |
| askfirst | 逻辑与`respawn`类似，但启动`process`前会输出提示语 “Please press Enter to activate this console”，需用户按回车后才启动。 | 需手动激活的控制台交互 |
| restart | 当 BusyBox 配置了`CONFIG_FEATURE_USE_INITTAB`，且 init 进程接收到 SIGHUP 信号时，会重新读取`/etc/inittab`并执行该`process`。 | 重新加载配置后的初始化任务 |
| shutdown | 系统接收到 “重启 / 关机命令” 时执行该`process`。 | 关机 / 重启前的资源清理任务 |
| ctrlaltdel | 用户按下`Ctrl+Alt+Del`组合键时执行该`process`。 | 快捷键触发的重启 / 操作任务 |

### 启动错误排查

内核启动成功，并且成功挂载了根文件系统，只是有很多的错误信息，错误信息如下：
```
can't run '/etc/init.d/rcS': No such file or directory
can't open /dev/tty2: No such file or directory
can't open /dev/tty3: No such file or directory
can't open /dev/tty4: No such file or directory
```

**解决思路**：<没有文件则创建对应的文件>
在根文件系统中创建`/etc/init.d`目录和`/dev`目录，并在`/etc/init.d`目录下添加`rcS`文件，修改`rcS`的文件权限为`777`.

```sh
# 进入根文件系统目录
cd ~/nfs/rootfs 

# 创建缺失的目录
mkdir -p etc/init.d dev 

# 创建并编辑 rcS 文件
cd etc/init.d 
touch rcS 
chmod 777 rcS
```

打开`rcS`文件，添加以下信息：
```sh
#!/bin/sh 
/bin/mount -a
echo /sbin/mdev > /proc/sys/kernel/hotplug 
/sbin/mdev -s
```

**解析**：
- `#!/bin/sh` ---> 使用sh脚本解析器
- `/bin/mount -a` ---> 系统会自动解析`fstab`配置文件，根据`fstab`文件中的信息，实现一系列的挂载动作。
- `echo /sbin/mdev > /proc/sys/kernel/hotplug` ---> 进行重定向，告诉内核用于创建设备文件的程序是`sbin/mdev`
- `/sbin/mdev -s` ---> 在`/dev`目录下自动创建设备文件

### 添加用户名

在根文件系统的`etc`目录下创建`profile`文件，并添加以下信息：
```sh
# 进入 etc 目录
cd ~/nfs/rootfs/etc 

# 编辑 profile 文件
vi profile 
```
添加的信息如下：
```sh
export HOSTNAME=20101-20111
export USER=root
export HOME=root
#export PS1="\[\u@\h \W\ ]\$ "
#cd root
export PS1="[$USER@$HOSTNAME \W]\# "
PATH=/bin:/sbin:/usr/bin:/usr/sbin:$PATH
LD_LIBRARY_PATH=/lib:/usr/lib:$LD_LIBRARY_PATH
export PATH LD_LIBRARY_PATH
```

# 第四天

*注意：以下图片链接为本地路径，可能无法正常显示。*
![76611045617](C:\Users\魏士雄\AppData\Local\Temp\1766110456178.png)

## ① 交叉工具链是什么？

> 交叉工具链是在 PC 上为嵌入式目标平台编译程序的一整套工具，包括 gcc、ld 以及对应的 libc。内核、BusyBox 和应用程序必须使用同一工具链，确保 ABI 一致。

## ② TFTP 是做什么的？路径如何配置？

> TFTP 主要用于开发阶段，通过网络向开发板传输内核和设备树。服务器端通过 tftpd 配置 `TFTP_DIRECTORY` 指定文件目录，U-Boot 使用 `tftp` 命令下载。

## ③ NFS 挂载 rootfs 的作用？

> NFS 用于通过网络挂载根文件系统，避免频繁烧写 Flash。服务器通过 `/etc/exports` 配置共享目录，内核通过 `bootargs` 指定 `nfsroot` 参数完成挂载。

## ④ 虚拟机和开发板网络怎么配？

> 一般使用桥接模式，让虚拟机、开发板和主机处于同一局域网，便于 TFTP 和 NFS 通信，这是嵌入式开发中最常用、最稳定的方式。

## ⑤ U-Boot 中 bootargs 和 bootcmd 的作用？

> `bootcmd` 定义 U-Boot 自动执行的启动命令，用于加载内核；`bootargs` 是传递给内核的启动参数，用于指定控制台、rootfs 类型和网络配置。

## ⑥ menuconfig 是做什么的？

> `menuconfig` 是基于 Kconfig 的配置工具，用于裁剪内核或 BusyBox 功能，最终生成 `.config` 文件，通过宏控制编译内容，实现体积和功能的平衡。

## ⑦ Kconfig 和 Makefile 如何配合？

> Kconfig 负责定义配置项并生成 `menuconfig` 菜单，Makefile 根据 `CONFIG_xxx` 宏决定目标文件是否参与编译，两者配合实现模块化和功能裁剪。

![76605015667](C:\Users\魏士雄\AppData\Local\Temp\1766050156677.png)
![76605302798](C:\Users\魏士雄\AppData\Local\Temp\1766053027982.png)
![76611364922](C:\Users\魏士雄\AppData\Local\Temp\1766113649222.png)
![76605306783](C:\Users\魏士雄\AppData\Local\Temp\1766053067838.png)
![76605292525](C:\Users\魏士雄\AppData\Local\Temp\1766052925254.png)
![76612289788](C:\Users\魏士雄\AppData\Local\Temp\1766122897881.png)
![76605385746](C:\Users\魏士雄\AppData\Local\Temp\1766053857467.png)
![76605400172](C:\Users\魏士雄\AppData\Local\Temp\1766054001725.png)
![76595899263](C:\Users\魏士雄\AppData\Local\Temp\1765958992631.png)
![76605435734](C:\Users\魏士雄\AppData\Local\Temp\1766054357345.png)
![76612382443](C:\Users\魏士雄\AppData\Local\Temp\1766123824435.png)
![76612399246](C:\Users\魏士雄\AppData\Local\Temp\1766123992468.png)
![76596248580](C:\Users\魏士雄\AppData\Local\Temp\1765962485808.png)